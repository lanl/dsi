import sqlite3
import re
import subprocess
from datetime import datetime
import textwrap
import os
import tarfile
import textwrap
import base64
import random

from hashlib import sha1
from dsi.backends.filesystem import Backend
from collections import OrderedDict

# HPSS backend class
class HPSS(Backend):
   def __init__(self, files, local_tmp_dir,  **kwargs):
        """
        Initializes an HPSS backend
        
        `files`: dictionary with hpss paths as keys and values with a dictionary format of 
        `local_tmp_dir`: a directory on a filesystem such as nfs, lustre, ext4, etc... to store HPSS files after a get command


         { 'local_path': path_on_local_fs, 
           'local_sha1': sha1 generated by dsi on local filesystem, 
           'hpss_hash':  hash from hpss,
           'tar_index':  tar index created by DSI
         } 
        """
        super().__init__(**kwargs)
        self.local_tmp_dir = local_tmp_dir
        self.hpss_info = OrderedDict()
        for hpss_file in files.keys():
           self.hpss_info[hpss_file] = {
              'local_path': files[hpss_file]['local_path'], 
              'local_sha1': files[hpss_file]['local_sha1'], 
              'hpss_hash': files[hpss_file]['hpss_hash'], 
              'tar_index': None
           }
           stdout, stderr, _ = self.run_hsi("hashlist", [hpss_file])
           hpss_hash = self.parse_hpss_hash(stdout, stderr)
           self.hpss_info[hpss_file]['hpss_hash'] = hpss_hash
           if files[hpss_file]['local_path'] and len(files[hpss_file]['local_path']) > 0 \
              and not files[hpss_file]['local_sha1'] or len(files[hpss_file]['local_sha1']) == 0:
              sha = sha1(open(files[hpss_file]['local_path'], 'rb').read())
              self.hpss_info[hpss_file]['local_sha1'] = sha
              
   def git_commit_sha(self):
      pass

   def create_hpss_hash(self) -> str:
      """
      Creates and HPSS hash
      """

      stdout, stderr, returncode = self.run_hsi("hashcreate", [hpss_file])
      if returncode != 0:
         print(stderr)

      hash = self.parse_hpss_hash(stdout, stderr)
      return hash

   def put(self, local_file, hpss_dest) -> bool:
      """
      Puts a local file on HPSS
      """

      cwd = os.getcwd()
      new_dir = None
      file_to_put = local_file
      if '/' in local_file:
        new_dir = '/'.join(local_file.split('/')[:-1])
        print(new_dir)
        os.chdir(new_dir)
        file_to_put = local_file.split('/')[-1]

      print(file_to_put)
      stdout, stderr, returncode = self.run_hsi("put", [file_to_put])
      if new_dir is not None:
        os.chdir(cwd)

      if returncode == 0:
         return True
      
      print(stderr)
      return False

   def get(self, tmp_dir, hpss_file) -> bool:
      """
      Gets an HPSS file and puts it in the tmp_dir
      """

      try:
         os.chdir(tmp_dir)
      except:
         print("Error changing to temp dir: %s" % tmp_dir)
         return False

      stdout, stderr, returncode = self.run_hsi("put", local_file)
      if returncode == 0:
         return True

      print(stderr)
      return False
   
   def parse_hpss_hash(self, stdout, stderr) -> str:
      """
      Parses the result of an HPSS hash command
      """

      output = stdout + stderr
      hash = None
      for line in output.splitlines():
         if " md5" not in line:
            continue

         print(line)
         line = line.strip()
         matches = re.search(r'(\S+)\s+(\S+)\s+(\S+).*', line)
         if not matches:
            continue

         if len(matches.groups()) == 3:
            hash = matches.group(1)
            break
            
      return hash
   
    # DEPRECATING IN FUTURE DSI RELEASE. USE ingest_artifacts()
   def put_artifacts(self, artifacts, kwargs) -> None:
      pass

   def ingest_artifacts(self, artifacts, kwargs) -> None:
      pass

    # DEPRECATING IN FUTURE DSI RELEASE. USE query_artifacts()
   def get_artifacts(self, query, kwargs):
      pass

   def query_artifacts(self, query, kwargs):
      pass

    # DEPRECATING IN FUTURE DSI RELEASE. USE notebook()
   def inspect_artifacts(self, kwargs):
      pass

   def notebook(self, kwargs):
      pass

    # DEPRECATING IN FUTURE DSI RELEASE. USE process_artifacts()
   def read_to_artifacts(self, kwargs):
      pass

   def process_artifacts(self, kwargs):
      pass

   def find(self, query_object, kwargs):
      pass

   def find_table(self, query_object, kwargs):
      pass

   def find_column(self, query_object, kwargs):
      pass

   def find_cell(self, query_object, kwargs):
      pass

   def close(self):
      pass

   def create_tar(self, tar_name="file.tar.gz", local_files=[]):
      """
      Creates a tar file and returns the index

      tar_name: name of the tar file to create with .tar.gz as the extension
      local_files: a list of files with full paths to include

      The tar file will be created in the local_tmp_dir directory
      """

      tar_path = self.local_tmp_dir + "/" + tar_name
      tar = tarfile.open(tar_path, "w:gz")
      for f in local_files:
         tar.add(f)
      tar.close()

      # Create an index. Taken from: https://stackoverflow.com/questions/2018512/reading-tar-file-contents-without-untarring-it-in-python-script
      tar = tarfile.open(tar_path)
      index = {i.name: i for i in tar.getmembers()}
      self.tar_index = ""
      for file_name in index.keys():
         self.tar_index += "%s : %d\n" % (file_name, index[file_name].size)

      print(self.tar_index)
      return True

   def run_hsi(self, subcmd, arg_list):
      """
      Runs hsi wth the supplied subcmd and arguments
      """

      command = ["hsi", subcmd]
      command += arg_list
      
      print(command)
      stdout = ""
      stderr = ""
      returncode = -1
      try:
         process = subprocess.Popen(command, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='latin-1')
         
         stdout, stderr = process.communicate()
         returncode = process.communicate()
      except FileNotFoundError as e:
         print("Error running hsi: %s" % e)
         
      return stdout, stderr, returncode
